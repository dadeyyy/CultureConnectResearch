liveStreamRoute.post('/startLiveStream', isAuthenticated, async (req, res) => {
  const body: { title: string; description: string; uid: string } = req.body;
  const user = req.session.user?.id;
  //Find user:
  const currentUser = await db.user.findUnique({ where: { id: user } });

  if (user && currentUser) {
    // await db.liveStream.create({
    //   data: {
    //     ...body,
    //     userId: currentUser.id,
    //   },
    // });

    //Get the list of the ongoing liveStream
    const onGoingLive = await fetch(`https://api.cloudflare.com/client/v4/accounts/${process.env.CLOUDFLARE_ACCOUNT_ID}/stream?status=live-inprogress`, {
      headers: {
        'Content-Type': 'application/json',
        'X-Auth-Email': `${process.env.CLOUDFLARE_EMAIL}`,
        Authorization: `Bearer ${process.env.CLOUDFLARE_TOKEN}`,
      }
    })
    
    const onGoingLiveData = await onGoingLive.json() as pastLiveStreamApiResponse;

    // const correspondingLiveStream = onGoingLiveData.result.find(stream => stream.liveInput === body.uid);
    // console.log('Corresponding Livestream', correspondingLiveStream);
    // const correspondingUid = correspondingLiveStream ? correspondingLiveStream.uid : null;
    // console.log('Corresponding UID', correspondingUid);
    
    const liveInputValues = onGoingLiveData.result.map(stream => stream.liveInput);

    

  // Check if the provided body.uid is included in the liveInputValues array
  const isLiveStreamOnGoing = liveInputValues.includes(body.uid);
    
    //If there is an ongoing liveStream with the same uid
    if(isLiveStreamOnGoing){
      return res.status(400).json({message: 'You cannot create two livestream at the same time'})
    }
  
    

    

    const setToAutomatic = await fetch(
      `https://api.cloudflare.com/client/v4/accounts/${process.env.CLOUDFLARE_ACCOUNT_ID}/stream/live_inputs/${body.uid}`,
      {
        headers: {
          'Content-Type': 'application/json',
          'X-Auth-Email': `${process.env.CLOUDFLARE_EMAIL}`,
          Authorization: `Bearer ${process.env.CLOUDFLARE_TOKEN}`,
        },
        method: 'PUT',
        body: JSON.stringify({
          meta: {
            name: `${body.title}`,
            description: `${body.description}`,
            fullName: `${currentUser.firstName} ${currentUser.lastName}`,
            username: `${currentUser.username}`,
          },
          recording: {
            mode: 'automatic',
          },
        }),
      }
    );

    if (setToAutomatic.ok) {
      const data = await setToAutomatic.json();
      res.status(200).json({ message: 'successfully created livestream!' });
    }
  }
});


liveStreamRoute.get('/getLiveStreams', async (req, res) => {
  try {
    const response = await axios.get(
      `https://api.cloudflare.com/client/v4/accounts/${process.env.CLOUDFLARE_ACCOUNT_ID}/stream/live_inputs`,
      {
        headers: {
          'Content-Type': 'application/json',
          'X-Auth-Email': `${process.env.CLOUDFLARE_EMAIL}`,
          Authorization: `Bearer ${process.env.CLOUDFLARE_TOKEN}`,
        },
      }
    );

    const { data } = response;

    if (data.success) {
      const liveInputs: LiveInput[] = data.result;

      const connectedLiveInputs = await Promise.all(
        liveInputs.map(async (input) => {
          const connectedData = await axios.get(
            `https://api.cloudflare.com/client/v4/accounts/${process.env.CLOUDFLARE_ACCOUNT_ID}/stream/live_inputs/${input.uid}`,
            {
              headers: {
                'Content-Type': 'application/json',
                'X-Auth-Email': `${process.env.CLOUDFLARE_EMAIL}`,
                Authorization: `Bearer ${process.env.CLOUDFLARE_TOKEN}`,
              },
            }
          );

          const { data } = connectedData;
          if (
            data.result.status !== null &&
            data.result.status.current.state === 'connected'
          ) {
            return data;
          }
        })
      );

      //Filter undefined
      const filteredConnectedLiveInputs = connectedLiveInputs.filter(
        (input) => input !== undefined
      );

      //Extract UID
      const connectedLiveInputsUIDs = filteredConnectedLiveInputs.map(
        (input) => input.result.uid
      );

      // Filter liveInputs based on the UIDs present in connectedLiveInputsUIDs
      const filteredLiveInputs = liveInputs.filter((input) =>
        connectedLiveInputsUIDs.includes(input.uid)
      );

      if (filteredLiveInputs.length > 0) {
        return res.status(200).json(filteredLiveInputs);
      }

      return res
        .status(404)
        .json({ message: 'No connected livestream available' });
    }
  } catch (error) {
    console.log(error);
    res.status(500).json({ error });
  }
});